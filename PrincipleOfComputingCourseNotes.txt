Notes here --: 
=====================================================================================================

<week_1>

- Designing Programs:

1. Read - Gather information about the problem from various information sources.
	- Read the problem definition / statement. Discuss the assignment with those who created it and your peers.
	- Gather examples of sample input and desired output.
	- Identify properties of the problem input. Understand and formulate properties of the output.
	- Read the documentation for any APIs/classes provided for the problem.
	
	
2. Think - Consider how to go about solving the problem.
	- Identify what you do and don't understand about solving the problem.
	- Focus on learning how to solve those parts that you don't understand. Read books, articles, forums, Stack Overflow, etc.
	- Experiment in isolation with solutions to parts of the problem that you don't understand.
	- Sketch a step-by-step solution to the problem in English. Refine this solution until you are confident 
	  that you understand all of the steps.
	  
3. Sketch - Outline the structure and functionality of your solution.
	- Decide on data representation (classes) and algorithms (methods) for core computational processes in the solution.
	- Formulate class definitions with needed methods as stubs (using pass or return).
	- Write docstrings for the methods that includes the data types for inputs and outputs.
	
4. Code and test - Implement and test the various methods in your class definitions.
	- Implement the initiailizer method __init__() for the class that lays out the basic class data in class fields.
	- Implement the string method __str__() method that returns a text representation of the class data.
	- Use the string method to test the initializer on several sets of test data created for the class.
	- For each remaining method, generate example input and output data.
	- Incrementally implement part of each method. Test your partial implementation on the test data. 
	  Add more test data as necessary.
	- Repeat this last step as necessary until the implementation is complete. 
	  Avoid adding large chunks of code to a method without testing.
	  
5. Review and refactor - Review each version of the solution. Refactor your code to eliminate common issues.
	- Identify repeated code fragments. Introduce appropriate abstractions to remove this duplicated code.
	- Decompose code into smaller logical pieces to avoid lengthy segments of code.
	- Think more and rewrite to simplify convoluted code.
	- Identify computational bottlenecks via counting and rewrite to improve the performance of slow-running code.
	
make a list of the steps that you follow when building a program to solve a particular problem. 
This list doesn't have to be particularly detailed, but should be a starting point

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<week_4>

1. Generators:
	Is an "Iterator", where a sequences of value is generated, just like a List, but differ from list in that, the whole
	sequences DOES NOT get produced all at once before iteration starts to initiate, rather, the value gets produce as
	iteration progresses.

 - Generator Expression (do not confuse with List Comprehension):
 	# A list comprehension
    print "max in list:", max([num * 2 - 3 for num in range(7)]) 
		# This expression generates a list before getting feed into the "max" function.

	# A generator expression
	print "max in gen:", max(num * 2 - 3 for num in range(7)) 
		# in this case "max" function takes in a value whenever it gets generated, not taking the whole list.

 - Generator Function:
 	contains the "yeild", which unlike "return", do not ends the function, but instead, gives (yeild) a value
	and continue to run the function until is told to stop.
	
	**However, Generator Function CAN contain "return" in order to stop the program.


2. Stacks and Queues:
	Types of data structure (e.g. Class defining) that restrict the way data getting extracted, 
	following LIFO for Stack and FIFO for Queues.
	
3. Inheritance:
	Subclass inherits methods from Baseclass, multiple subclasses can inherits from the same base.
	Methods that got redefined in subclasses will Overwrite the methods with the same names from base.
	
	syntax for defining a subclass that inherits from a baseclass named Base:
	
	>>> class Sub(Base):
	

4. Duck Typing:
	A way of variables handling used in some languagues such as python, that many others do not, like Java.
	In language that uses duck typing, types of variables are not explicitly defined, thus a program will not
	consider whether a method is suitable to be called on the variable before executing to ensure correct behavior, 
	rather it will throw errors when execution fails.
	"When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck"
	

5. Search method:
	
	-BFS: where an initial point is chosen, and the search spread outward in all directions, checking whether 
	      the neighbor of those searched cells are searched and update accordingly.
	
	-DFS: where an initial point is given, and the search begin	the search unidirectionally until deadend is reached,
	      then change another direction to continue.
	



